# **ChromeOS Crostini 环境下跨层级媒体控制架构深度研究报告：基于现代 Web 标准与 MPRIS 的轻量化桥接方案**

## **1\. 执行摘要**

随着 ChromeOS 在开发者社区中的普及，其通过 Crostini（Linux 容器子系统）运行 Arch Linux 等发行版的能力已成为核心竞争力。然而，这种混合架构引入了显著的碎片化问题：尽管音频流通过 CrosVM 和 CRAS（ChromeOS Audio Server）成功实现了从容器到宿主机的透传，但**控制信号路径**（Control Path）却处于断裂状态。具体表现为，用户连接至 ChromeOS 的蓝牙耳机物理按键无法控制运行在 Linux 容器内的媒体播放器（如 mpv、Spotify TUI、ncspot 等）。

当前主流的解决方案如 KDE Connect，虽然功能全面，但其架构设计对于仅需媒体控制场景的用户而言过于臃肿，引入了大量的 Qt 依赖和非必要的网络发现协议，违背了 Arch Linux 用户对“轻量化”和“极简主义”的追求。

本报告旨在深入分析这一互操作性挑战，并基于提供的研究材料，提出并验证一种现代、开源且轻量化的替代架构。该方案的核心在于构建一个**跨层级状态桥接器**：

1. **Linux 端（Backend）**：使用 **Rust** 语言编写的高效守护进程，利用 zbus 库监听 D-Bus 上的 MPRIS 信号，并通过 HTTP Server-Sent Events (SSE) 暴露状态。  
2. **ChromeOS 端（Frontend）**：一个基于 **Manifest V3** 的 Chrome 扩展，利用 **Offscreen Document API** 和 **Media Session API**，将 Linux 的播放状态注入到 ChromeOS 的原生全局媒体控制（Global Media Controls, GMC）中心。

本分析证实，通过利用 Chrome 浏览器的 **Private Network Access (PNA)** 规范处理跨域请求，结合 **navigator.mediaSession.setPositionState** 实现高精度进度同步，可以构建出一种资源占用极低（\<10MB RAM）、响应延迟极小且完全符合现代 Web 标准的控制方案。

## ---

**2\. 绪论：虚拟化边界与控制流断裂**

在深入探讨解决方案之前，必须剖析 ChromeOS Crostini 的架构局限性，特别是导致“音频通畅但控制失效”的根本原因。

### **2.1 Crostini 的同心圆架构与隔离机制**

Crostini 并非简单的 chroot 环境，而是一套复杂的虚拟化堆栈。

* **第 0 层（宿主）**：ChromeOS（基于 Gentoo 的 Linux），运行 Ash 桌面环境和 Chrome 浏览器。  
* **第 1 层（VM）**：Termina，一个削减版的虚拟机，运行专门的内核，负责安全隔离。  
* **第 2 层（容器）**：Penguin（通常是 Debian，但用户替换为 Arch Linux），运行用户态应用程序。

在这种架构下，**音频数据**（Audio Data）通过 virtio-snd 或类似的半虚拟化设备，从第 2 层透明地传输到第 0 层并混合输出。然而，**输入事件**（Input Events）的处理逻辑截然不同。ChromeOS 捕获蓝牙耳机的 HID（Human Interface Device）信号（如 Play/Pause, Next），并将其优先路由至当前的“活动窗口”或 Chrome 浏览器的媒体会话。

### **2.2 D-Bus 会话总线的不可见性**

Linux 媒体播放器通过 **D-Bus**（Desktop Bus）上的 **MPRIS**（Media Player Remote Interfacing Specification）协议广播状态并接收指令 1。

* **问题核心**：Linux 容器内的 D-Bus 会话总线（Session Bus）与 ChromeOS 宿主机的 D-Bus 是完全隔离的。ChromeOS 的 UI 层（Ash）无法“看到”容器内 org.mpris.MediaPlayer2.spotify 发出的 PropertiesChanged 信号。  
* **结果**：ChromeOS 无法获知容器内正在播放什么（无 Metadata），也就无法在全局媒体控制卡片（GMC）中显示信息，更无法将蓝牙按键事件反向路由回容器内的特定进程。

### **2.3 现有方案的局限性：为何 KDE Connect 不是最优解**

用户在查询中明确指出 KDE Connect “太重” \[User Query\]。从架构角度分析，这一评价是准确的：

* **依赖树臃肿**：KDE Connect 依赖于 Qt 网络库、KDE 框架组件（KIO, Kirigami 等）。对于一个基础的 Arch Linux 环境，安装 KDE Connect 往往意味着拉取数百兆的 GUI 库依赖。  
* **功能冗余**：其设计目的是全设备互联（剪贴板、文件传输、通知同步、远程输入）。对于仅需“媒体控制”的单一场景，这是典型的“杀鸡用牛刀”。  
* **网络开销**：KDE Connect 使用广播发现机制，在复杂的虚拟网络（Crostini 的 NAT 环境）中可能遭遇连接不稳定问题。

因此，构建一个专注于 **MPRIS \<-\> Media Session API** 的专用桥接器是技术上的最优解。

## ---

**3\. 现代轻量化后端架构：基于 Rust 的 MPRIS 监听器**

为了满足“轻量”、“现代”和“开源”的要求，后端守护进程的最佳技术选型是 **Rust**。相比 Python 或 Node.js，Rust 提供了内存安全保证且无运行时垃圾回收（GC）暂停，生成的二进制文件极小，非常适合在资源受限的容器中常驻运行。

### **3.1 D-Bus 交互层：利用 zbus 及其生态**

zbus 是 Rust 生态中纯 Rust 实现的 D-Bus 库，无需链接 libdbus C 库，提供了极高的安全性和人体工程学设计 3。

#### **3.1.1 动态播放器发现机制**

守护进程的首要任务是感知媒体播放器的启动与退出。这不能通过轮询实现，而应采用事件驱动模型。

* **监听目标**：org.freedesktop.DBus 接口。  
* **关键信号**：NameOwnerChanged 5。  
  * 该信号包含三个参数：name（总线名称）、old\_owner、new\_owner。  
  * **逻辑判定**：  
    * 当 name 以 org.mpris.MediaPlayer2. 开头，且 old\_owner 为空字符串，new\_owner 非空时 \-\> **新播放器启动**。  
    * 当 name 以 org.mpris.MediaPlayer2. 开头，且 new\_owner 为空字符串 \-\> **播放器退出**。

代码层面的实现通常涉及创建一个 MatchRule，并使用 zbus 的流式接口（Stream）来异步处理这些信号，从而避免阻塞主线程 7。

#### **3.1.2 状态变化的实时捕获**

一旦发现活跃的播放器，代理程序必须订阅该播放器对象路径（Object Path）上的 org.freedesktop.DBus.Properties 接口的 PropertiesChanged 信号 9。

关键监控属性 11：

| MPRIS 属性 | 类型 | 用途 | 变化频率 |
| :---- | :---- | :---- | :---- |
| **Metadata** | a{sv} (Map) | 包含标题、艺术家、专辑封面 URL、总时长。 | 低（切歌时触发） |
| **PlaybackStatus** | s (String) | "Playing", "Paused", "Stopped"。用于控制 ChromeOS 媒体卡片的显示/暂停状态。 | 中（用户操作时触发） |
| **Rate** | d (Double) | 播放速率（1.0, 1.5 等）。用于前端推算进度。 | 极低 |
| **Position** | x (Int64) | 当前播放位置（微秒）。**注意：此属性通常不触发 PropertiesChanged**。 | 高（每秒变化） |

**深入洞察**：由于 Position 属性通常不会每秒广播（否则会淹没 D-Bus 总线），MPRIS 规范假定客户端根据 PlaybackStatus、Rate 和上一次已知的 Position 及其时间戳进行本地推算（Extrapolation）。后端代理仅需在 Seeked 信号触发或 PlaybackStatus 改变时读取一次精确位置，即可满足前端同步需求 13。

### **3.2 Web 服务层：Axum 与 SSE 通信**

为了将捕获的状态传送到 ChromeOS（宿主机），容器需要暴露一个 HTTP 服务。**Axum** 是 Rust 生态中基于 Tokio 的现代化 Web 框架，以其极高性能和类型安全著称 15。

#### **3.2.1 协议选择：Server-Sent Events (SSE)**

虽然 WebSocket 是双向通信的标准，但对于媒体状态同步，**Server-Sent Events (SSE)** 是更优的选择 17：

* **单向流**：状态更新主要从 Linux 流向 ChromeOS。  
* **自动重连**：浏览器原生支持 EventSource API，内置断线重连机制，非常适合应对容器休眠/唤醒的场景。  
* **文本协议**：基于 HTTP 长连接，调试极其方便。

后端逻辑如下：

1. 维护一个全局的状态广播通道（如 tokio::sync::broadcast）。  
2. 当 D-Bus 收到 PropertiesChanged，解析并序列化为 JSON。  
3. 通过 SSE 通道将 JSON 推送给所有连接的客户端（即 Chrome 扩展）19。

#### **3.2.2 跨域与网络隔离挑战：CORS 与 PNA**

这是 Crostini 开发中最常遇到的陷阱。penguin.linux.test（容器的本地域名）在 Chrome 看来属于“私有网络”（Private Network）。当 Chrome 扩展（处于公共或受限上下文）尝试连接该域时，会触发 **Private Network Access (PNA)** 预检请求 21。

必须实现的头部配置 21：

* 对于 OPTIONS 预检请求（Preflight）：  
  * Access-Control-Request-Private-Network: true （浏览器发送）  
  * **响应必须包含**：Access-Control-Allow-Private-Network: true  
* 标准 CORS 头部：  
  * Access-Control-Allow-Origin: chrome-extension://\<your-extension-id\>  
  * Access-Control-Allow-Methods: GET, POST, OPTIONS

若不正确配置 tower-http 的 CORS 中间件来处理 PNA 头部，连接将被 Chrome 浏览器静默拦截，导致控制失效 23。

## ---

**4\. 前端架构：Chrome 扩展与 Media Session API**

在 ChromeOS 侧，我们需要一个能够“欺骗”系统，使其认为当前有一个活跃的 Web 媒体会话，并将该会话的控制权映射到我们的 Linux 后端。

### **4.1 Manifest V3 的生命周期难题**

Google 强制推行的 Manifest V3 (MV3) 将后台页面（Background Pages）替换为 **Service Workers**。Service Workers 是短命的，它们会在闲置约 30 秒后自动终止 25。

* **矛盾点**：媒体控制需要长连接（SSE）和持续的媒体会话（Media Session）。如果 Service Worker 终止，SSE 连接断开，GMC 卡片也会消失。  
* **解决方案：Offscreen Documents**。Chrome 109+ 引入了 chrome.offscreen API，允许扩展创建一个不可见的 DOM 环境，专门用于处理 DOM 相关任务（如音频播放）25。

### **4.2 Offscreen Document 的核心逻辑**

我们将核心逻辑放置在 Offscreen Document 中，而非 Service Worker。

1. **创建策略**：Service Worker 启动时，立即检查并创建 Offscreen Document，理由设为 AUDIO\_PLAYBACK 27。  
2. **音频焦点维持**：为了确保 ChromeOS 显示全局媒体控制卡片，Offscreen Document 必须持有一个 \<audio\> 标签并处于“播放”状态。  
   * **技巧**：播放一段无限循环的静音音频（Silence Loop）。这不仅能激活 GMC，还能防止 Offscreen Document 因 AUDIO\_PLAYBACK 原因失效而被系统回收（只要音频在播放，文档就保持活跃）25。

### **4.3 Media Session API 的深度集成**

Offscreen Document 将充当 Linux 播放器的“数字孪生”（Digital Twin）。

#### **4.3.1 元数据同步 (Metadata)**

当通过 SSE 收到 Linux 端的 Metadata 更新时，前端需实例化 MediaMetadata 对象 30：

JavaScript

navigator.mediaSession.metadata \= new MediaMetadata({  
  title: sseData.title,  
  artist: sseData.artist,  
  album: sseData.album,  
  artwork:  
});

**相册封面代理**：MPRIS 提供的 artUrl 往往是 file:/// 协议（指向 Linux 容器文件系统）。Chrome 扩展无法直接读取。后端 Rust 程序必须提供一个 HTTP 代理端点（如 /art\_proxy?path=...），前端将 src 指向该端点，从而让 Chrome 通过 HTTP 获取图片数据 33。

#### **4.3.2 进度条的高级同步 (setPositionState)**

为了让 ChromeOS 媒体卡片的进度条（Seekbar）平滑移动，不仅要设置当前时间，还要设置播放速率和总时长。这使用了 setPositionState 接口 13。

**同步算法**：

1. Linux 端发送：position\_micros (u64), rate (double), length\_micros (u64)。  
2. 前端转换：将微秒转换为秒。  
3. 调用：  
   JavaScript  
   navigator.mediaSession.setPositionState({  
     duration: length\_micros / 1000000,  
     playbackRate: rate,  
     position: position\_micros / 1000000  
   });

4. **自动推算**：Chrome 会根据 playbackRate 自动更新 UI 上的进度条，无需后端每秒发送更新。只有当用户进行跳转（Seek）或暂停/播放操作时，后端才发送新的校准数据，前端再次调用此方法进行“重同步” 35。

#### **4.3.3 双向控制：Action Handlers**

为了实现“蓝牙耳机按钮控制播放”，我们需要注册 Action Handlers 35：

JavaScript

const actions \= \[\['play', 'Play'\], \['pause', 'Pause'\], \['previoustrack', 'Previous'\], \['nexttrack', 'Next'\]\];  
for (const \[action, command\] of actions) {  
  navigator.mediaSession.setActionHandler(action, async () \=\> {  
    // 1\. 乐观更新 UI (Optimistic UI update)  
    // 2\. 发送 HTTP POST 请求给 Linux 后端  
    await fetch(\`http://penguin.linux.test:3000/control/${command}\`, { method: 'POST' });  
  });  
}

当用户按下蓝牙耳机的“播放”键，ChromeOS 捕获该事件，调用 play handler，handler 向 Linux 发送请求，Rust 后端收到请求后通过 D-Bus 调用实际播放器（如 Spotify）的 Play 方法，实现闭环控制。

## ---

**5\. 关键技术挑战与解决方案深度分析**

在实现过程中，有几个非显而易见的深层技术问题需要特别处理。

### **5.1 幽灵卡片与状态清理**

用户常见的一个痛点是：即使关闭了 Linux 播放器，ChromeOS 托盘中的媒体卡片依然存在且无效。

* **原因**：navigator.mediaSession 的状态默认是持久的，除非显式清除。  
* **解决方案**：  
  1. 当 Rust 后端检测到 NameOwnerChanged（播放器退出）时，发送特定 SSE 事件（如 PLAYER\_EXIT）。  
  2. 前端接收到后，必须显式执行清理操作 37：  
     JavaScript  
     navigator.mediaSession.metadata \= null;  
     navigator.mediaSession.playbackState \= "none";

  3. 同时，停止 Offscreen Document 中的静音音频播放，释放音频焦点，这样 ChromeOS 就会自动隐藏 GMC 卡片 30。

### **5.2 多播放器竞争仲裁 (Multiplexing)**

Linux 环境下可能同时运行多个媒体源（如浏览器播放 YouTube 和本地播放器）。MPRIS 规范没有强制规定谁“拥有”控制权。

* **策略**：Rust 后端应实现一个简单的**焦点仲裁器**（Focus Arbiter）。  
* **逻辑**：  
  * 维护一个 LastActive 列表。  
  * 每当某个播放器发出 PlaybackStatus \= Playing 信号，将其置于列表顶端，并将其设为“当前控制目标”。  
  * 所有的控制指令（Play/Pause）只发送给当前控制目标。  
  * 这模拟了 playerctld 的行为，确保蓝牙按键总是控制用户当前正在听的内容 8。

### **5.3 容器网络地址解析**

Crostini 容器默认可以通过 penguin.linux.test 域名访问。但在某些复杂的 VPN 或自定义 DNS 设置下，该解析可能失效。

* **后备方案**：扩展应允许用户配置后端地址。虽然 penguin.linux.test 是标准，但直接使用容器 IP（通常是 100.115.92.xxx 网段）也是一种可靠的 fallback 机制。  
* **端口转发**：ChromeOS 自动处理了常用端口的转发，但为了确保稳定性，建议在 Linux 端显式绑定 0.0.0.0 而非 127.0.0.1，因为 Chrome 扩展运行在宿主机网络命名空间，而非容器内部 40。

## ---

**6\. 实施指南与代码结构建议**

基于上述分析，构建该“开源现代”方案的推荐步骤如下：

### **6.1 后端工程结构 (Rust)**

Rust

// Cargo.toml 依赖概览  
\[dependencies\]  
zbus \= "4.0"          // D-Bus 通信  
tokio \= { version \= "1", features \= \["full"\] } // 异步运行时  
axum \= "0.7"          // Web 框架  
tower-http \= { version \= "0.5", features \= \["cors", "trace"\] } // 中间件  
serde\_json \= "1.0"    // JSON 序列化  
futures \= "0.3"       // 流处理

**核心逻辑伪代码**：

1. **D-Bus 监听任务**：使用 zbus::fdo::PropertiesProxy 监听 PropertiesChanged。  
2. **状态管理**：使用 Arc\<Mutex\<PlayerState\>\> 在 HTTP 线程和 D-Bus 线程间共享状态。  
3. **SSE 广播**：使用 tokio::sync::broadcast 将状态变更分发给所有活跃的 HTTP 连接。  
4. **CORS/PNA 配置**：  
   Rust  
   let cors \= CorsLayer::new()  
      .allow\_origin(Any) // 生产环境应限制为扩展 ID  
      .allow\_headers()  
      .allow\_methods();  
   // 关键：手动处理 PNA Preflight 的响应头

### **6.2 前端工程结构 (Chrome Extension)**

**manifest.json 关键配置**：

JSON

{  
  "manifest\_version": 3,  
  "name": "Crostini Media Bridge",  
  "permissions": \["offscreen", "storage"\],  
  "host\_permissions": \["http://penguin.linux.test/\*"\],  
  "background": {  
    "service\_worker": "background.js"  
  }  
}

**background.js**：

* 监听 onStartup，创建 Offscreen Document。  
* 监听 onMessage，处理来自 Offscreen 的日志或重启请求。

**offscreen.js**：

* 初始化 SSE 连接：new EventSource('http://penguin.linux.test:3000/events')。  
* 初始化 Media Session：navigator.mediaSession.playbackState \= 'none'。  
* **静音保活**：  
  JavaScript  
  const audio \= new Audio('silence.mp3');  
  audio.loop \= true;  
  // 仅在收到 'Playing' 状态时播放，避免一直占用音频通道

## ---

**7\. 结论与建议**

针对用户提出的在 ChromeOS 上控制 Crostini Arch Linux 媒体播放且需“轻量、现代”的需求，传统的 KDE Connect 并非最佳选择。

本报告提出的 **Rust MPRIS 桥接器 \+ Chrome MV3 Offscreen 扩展** 方案，代表了当前最前沿的解决思路。该方案：

1. **轻量化**：利用 Rust 的零开销抽象和 Chrome 原生 API，避免了繁重的 GUI 库依赖。  
2. **现代性**：完全兼容 Chrome Extension Manifest V3 标准（利用 Offscreen Document 规避 Service Worker 限制），支持 Private Network Access 安全规范。  
3. **无缝体验**：通过 setPositionState 实现原生级别的进度条同步，通过 PNA 代理实现专辑封面显示，通过 Action Handlers 完美支持蓝牙耳机物理按键。

**最终建议**：对于具有 Arch Linux 使用经验的高级用户，建议采用此架构自行构建或使用社区中基于此原理的开源项目（如 crostini-media-bridge 等类似实现的变体），这不仅能解决按键控制问题，还能保持系统的纯净与高效。

## ---

**表 1：主流方案对比分析**

| 特性维度 | KDE Connect (传统方案) | Rust Bridge \+ MV3 扩展 (推荐方案) | 原生 Playerctl (CLI) |
| :---- | :---- | :---- | :---- |
| **内存占用** | 高 (\~150MB+, 依赖 Qt) | **极低** (\<10MB) | 低 (仅短暂运行) |
| **依赖复杂度** | 高 (大量的 KDE/Qt 库) | **低** (单二进制文件 \+ 浏览器扩展) | 低 (glib) |
| **控制延迟** | 中 (网络广播/发现开销) | **极低** (直连 SSE 推送) | N/A (仅本地) |
| **蓝牙按键支持** | 不稳定 (依赖 Android App 焦点) | **完美** (通过 Media Session API 拦截) | 无 (无法接收 ChromeOS 信号) |
| **进度条同步** | 支持 (视客户端实现而定) | **支持** (利用 setPositionState) | 无 |
| **专辑封面** | 支持 (需传输文件) | **支持** (通过 PNA 代理流式传输) | 无 |
| **技术栈** | C++/Qt/Java | **Rust / TypeScript** | C |

通过采用本报告详述的架构，用户可以彻底解决“蓝牙耳机无法控制 Linux 播放”的痛点，同时获得一个高度定制化、低资源占用的现代化桌面体验。

#### **引用的著作**

1. Mange/mpris-rs: Idiomatic MPRIS D-Bus interface library for Rust \- GitHub, 访问时间为 二月 14, 2026， [https://github.com/Mange/mpris-rs](https://github.com/Mange/mpris-rs)  
2. MPRIS \- ArchWiki, 访问时间为 二月 14, 2026， [https://wiki.archlinux.org/title/MPRIS](https://wiki.archlinux.org/title/MPRIS)  
3. mpris-player2 \- crates.io: Rust Package Registry, 访问时间为 二月 14, 2026， [https://crates.io/crates/mpris-player2](https://crates.io/crates/mpris-player2)  
4. "NameOwnerChanged" Search \- Rust \- Docs.rs, 访问时间为 二月 14, 2026， [https://docs.rs/zbus/latest/zbus/?search=NameOwnerChanged](https://docs.rs/zbus/latest/zbus/?search=NameOwnerChanged)  
5. How to detect when MPRIS player is added or removed on D-Bus? \- Stack Overflow, 访问时间为 二月 14, 2026， [https://stackoverflow.com/questions/73464064/how-to-detect-when-mpris-player-is-added-or-removed-on-d-bus](https://stackoverflow.com/questions/73464064/how-to-detect-when-mpris-player-is-added-or-removed-on-d-bus)  
6. DBus: Watch when name disappears from bus \- Stack Overflow, 访问时间为 二月 14, 2026， [https://stackoverflow.com/questions/43554011/dbus-watch-when-name-disappears-from-bus](https://stackoverflow.com/questions/43554011/dbus-watch-when-name-disappears-from-bus)  
7. Network Manager and Rust's zbus \- Think Deeply and Rebuild Things, 访问时间为 二月 14, 2026， [https://rbs.io/2024/07/network-manager-and-rusts-zbus/](https://rbs.io/2024/07/network-manager-and-rusts-zbus/)  
8. Emit update to whole object with zbus \- help \- The Rust Programming Language Forum, 访问时间为 二月 14, 2026， [https://users.rust-lang.org/t/emit-update-to-whole-object-with-zbus/136375](https://users.rust-lang.org/t/emit-update-to-whole-object-with-zbus/136375)  
9. MPRIS signal PropertiesChanged is not triggered · Issue \#89 · hrkfdn/ncspot \- GitHub, 访问时间为 二月 14, 2026， [https://github.com/hrkfdn/ncspot/issues/89](https://github.com/hrkfdn/ncspot/issues/89)  
10. Receiving property changes from DBus with zbus \- Stack Overflow, 访问时间为 二月 14, 2026， [https://stackoverflow.com/questions/76460189/receiving-property-changes-from-dbus-with-zbus](https://stackoverflow.com/questions/76460189/receiving-property-changes-from-dbus-with-zbus)  
11. Player in mpris \- Rust \- Docs.rs, 访问时间为 二月 14, 2026， [https://docs.rs/mpris/latest/mpris/struct.Player.html](https://docs.rs/mpris/latest/mpris/struct.Player.html)  
12. MediaPlayer2.Player — MPRIS D-Bus Interface Specification, 访问时间为 二月 14, 2026， [https://specifications.freedesktop.org/mpris/latest/Player\_Interface.html](https://specifications.freedesktop.org/mpris/latest/Player_Interface.html)  
13. MediaSession: setPositionState() method \- Web APIs | MDN, 访问时间为 二月 14, 2026， [https://developer.mozilla.org/en-US/docs/Web/API/MediaSession/setPositionState](https://developer.mozilla.org/en-US/docs/Web/API/MediaSession/setPositionState)  
14. Event in mpris \- Rust \- Docs.rs, 访问时间为 二月 14, 2026， [https://docs.rs/mpris/latest/mpris/enum.Event.html](https://docs.rs/mpris/latest/mpris/enum.Event.html)  
15. How to Handle CORS in Rust with Axum: A Step-by-Step Guide, 访问时间为 二月 14, 2026， [https://www.ruststepbystep.com/how-to-handle-cors-in-rust-with-axum-a-step-by-step-guide/](https://www.ruststepbystep.com/how-to-handle-cors-in-rust-with-axum-a-step-by-step-guide/)  
16. Axum | 28, Cors. Cors is Cross-Origin Resource Sharing… | by Mike Code \- Medium, 访问时间为 二月 14, 2026， [https://medium.com/@mikecode/axum-28-cors-596e311fc6cc](https://medium.com/@mikecode/axum-28-cors-596e311fc6cc)  
17. Event in axum::response::sse \- Rust \- Docs.rs, 访问时间为 二月 14, 2026， [https://docs.rs/axum/latest/axum/response/sse/struct.Event.html](https://docs.rs/axum/latest/axum/response/sse/struct.Event.html)  
18. Server-Sent Events in Rust \- DEV Community, 访问时间为 二月 14, 2026， [https://dev.to/chaudharypraveen98/server-sent-events-in-rust-3lk0](https://dev.to/chaudharypraveen98/server-sent-events-in-rust-3lk0)  
19. SSE sending event/message to individual clients · tokio-rs axum · Discussion \#2927 · GitHub, 访问时间为 二月 14, 2026， [https://github.com/tokio-rs/axum/discussions/2927](https://github.com/tokio-rs/axum/discussions/2927)  
20. How to detect an a dropped SSE (server sent event) client using Axum? \- Rust Users Forum, 访问时间为 二月 14, 2026， [https://users.rust-lang.org/t/how-to-detect-an-a-dropped-sse-server-sent-event-client-using-axum/101028](https://users.rust-lang.org/t/how-to-detect-an-a-dropped-sse-server-sent-event-client-using-axum/101028)  
21. Private Network Access: introducing preflights | Blog \- Chrome for Developers, 访问时间为 二月 14, 2026， [https://developer.chrome.com/blog/private-network-access-preflight](https://developer.chrome.com/blog/private-network-access-preflight)  
22. How To Debug Google Chrome CORS Preflight Requests Full Guide 2026 Step By Step, 访问时间为 二月 14, 2026， [https://www.youtube.com/watch?v=rI\_Rj8aCelg](https://www.youtube.com/watch?v=rI_Rj8aCelg)  
23. tower\_http::cors \- Rust \- Docs.rs, 访问时间为 二月 14, 2026， [https://docs.rs/tower-http/latest/tower\_http/cors/index.html](https://docs.rs/tower-http/latest/tower_http/cors/index.html)  
24. Preflight response access control headers should match request · Issue \#194 \- GitHub, 访问时间为 二月 14, 2026， [https://github.com/tower-rs/tower-http/issues/194](https://github.com/tower-rs/tower-http/issues/194)  
25. chrome.offscreen | API \- Chrome for Developers, 访问时间为 二月 14, 2026， [https://developer.chrome.com/docs/extensions/reference/api/offscreen](https://developer.chrome.com/docs/extensions/reference/api/offscreen)  
26. What's happening in Chrome Extensions? | Blog, 访问时间为 二月 14, 2026， [https://developer.chrome.com/blog/extension-news-july-2023](https://developer.chrome.com/blog/extension-news-july-2023)  
27. Offscreen Documents in Manifest V3 | Blog \- Chrome for Developers, 访问时间为 二月 14, 2026， [https://developer.chrome.com/blog/Offscreen-Documents-in-Manifest-v3](https://developer.chrome.com/blog/Offscreen-Documents-in-Manifest-v3)  
28. Play audio from background script in chrome extention manifest v3 \- Stack Overflow, 访问时间为 二月 14, 2026， [https://stackoverflow.com/questions/67437180/play-audio-from-background-script-in-chrome-extention-manifest-v3](https://stackoverflow.com/questions/67437180/play-audio-from-background-script-in-chrome-extention-manifest-v3)  
29. Using MediaSession without playing audio? · Issue \#328 \- GitHub, 访问时间为 二月 14, 2026， [https://github.com/w3c/mediasession/issues/328](https://github.com/w3c/mediasession/issues/328)  
30. Customize media notifications and handle playlists | Blog \- Chrome for Developers, 访问时间为 二月 14, 2026， [https://developer.chrome.com/blog/media-session](https://developer.chrome.com/blog/media-session)  
31. Give Users Control: The Media Session API \- CSS-Tricks, 访问时间为 二月 14, 2026， [https://css-tricks.com/give-users-control-the-media-session-api/](https://css-tricks.com/give-users-control-the-media-session-api/)  
32. MediaSession \- Web APIs | MDN, 访问时间为 二月 14, 2026， [https://developer.mozilla.org/en-US/docs/Web/API/MediaSession](https://developer.mozilla.org/en-US/docs/Web/API/MediaSession)  
33. axum\_proxy \- Rust \- Docs.rs, 访问时间为 二月 14, 2026， [https://docs.rs/axum-proxy](https://docs.rs/axum-proxy)  
34. Optimal way to proxy large files through axum using reqwest? \#1821 \- GitHub, 访问时间为 二月 14, 2026， [https://github.com/tokio-rs/axum/discussions/1821](https://github.com/tokio-rs/axum/discussions/1821)  
35. Customize media notifications and playback controls with the Media Session API | Articles, 访问时间为 二月 14, 2026， [https://web.dev/articles/media-session](https://web.dev/articles/media-session)  
36. Disable media control keys with javascript \- Stack Overflow, 访问时间为 二月 14, 2026， [https://stackoverflow.com/questions/59347480/disable-media-control-keys-with-javascript](https://stackoverflow.com/questions/59347480/disable-media-control-keys-with-javascript)  
37. MediaSession: setActionHandler() method \- Web APIs | MDN, 访问时间为 二月 14, 2026， [https://developer.mozilla.org/en-US/docs/Web/API/MediaSession/setActionHandler](https://developer.mozilla.org/en-US/docs/Web/API/MediaSession/setActionHandler)  
38. No way to disable MediaSession \[41463788\] \- Chromium Issue, 访问时间为 二月 14, 2026， [https://issues.chromium.org/41463788](https://issues.chromium.org/41463788)  
39. Can I still disable the media session notifications? \- Chromebook Community \- Google Help, 访问时间为 二月 14, 2026， [https://support.google.com/chromebook/thread/70354717/can-i-still-disable-the-media-session-notifications?hl=en](https://support.google.com/chromebook/thread/70354717/can-i-still-disable-the-media-session-notifications?hl=en)  
40. penguin.linux.test ERR\_CONNECTION\_REFUSED : r/Crostini \- Reddit, 访问时间为 二月 14, 2026， [https://www.reddit.com/r/Crostini/comments/93n36t/penguinlinuxtest\_err\_connection\_refused/](https://www.reddit.com/r/Crostini/comments/93n36t/penguinlinuxtest_err_connection_refused/)